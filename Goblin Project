@name Goblin Project
@persist MOVEW MOVES MOVEA MOVED DOWN Turning MoveVal MOVEMAX ShiftVal [RFoot LFoot LHand RHand LeftLegFly RightLegFly]:vector Step WalkRate Yaw [Ranger2 Ranger3]:ranger M2Val M2Val2 EditMode
@persist [Base Seat PodController]:entity DriverTargets:array Length1_Arm Length2_Arm Length1_Leg Length2_Leg On_Ground2 [LocalEyes PelvisAng]:angle HasJumpPack
@persist [HT CT Bones Animation BoneParents]:table [SpawnStatus CoreStatus]:string [HN CN I SpawnCounter] DriverStore:entity Pistolfirerate ZoomLevel
@persist [JiggleTable AnimationAngles]:table BASEANGVEL:angle TP LaserCT SpaceForABit Flying MixFans FlyingStart RotorRPM DN2 FlyingStart2 FlyingStartVal MovementBlock Boosting Landed BoostData:table Nodes DistBelt CamParent:entity CamPos:vector CamDist CamFOV StartedBoosting StartPos:vector M2Val3 M2Val3Increase PodControllerW:wirelink
@model models/hunter/misc/sphere075x075.mdl
if(dupefinished()){reset()}
if(first()){
    
    propSpawnUndo(0)
    Base=entity()
    Base:propFreeze(1)
    Base:propDraw(0)
    Base:setMass(1000)
    Base:propPhysicalMaterial("canister")
    noCollideAll(Base,0)
    Base:makeSpherical(6+6/2)
    Base:propInertia(vec(100))
    
    Seat = seatSpawn("models/nova/airboat_seat.mdl",1)
    Seat:setAlpha(0)
    rangerFilter(array(Seat,Base))
    rangerPersist(1)
    
    DriverTargets = array(owner())
    
    Color1 = vec4(255,255,255,255)
    Color2 = vec4(150,150,150,255)
    LaserColor = vec4(0,255,255,255)
    
    ShowBones=0
    ShowBonesAll=0
    EditMode=0
    Model = 1
    
    Length1_Arm=17
    Length2_Arm=16
    Length1_Leg=19
    Length2_Leg=20
    
    S=I=1, HN++, HT[HN,array] = array(I, noentity(), noentity(), 0, vec(0, 0, 0), ang(0, 0, 0), ShowBones*ShowBonesAll, "models/sprops/geometry/sphere_3.mdl"),Bones["Root",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Root",number], Seat, 0, vec(0, 0, 0), ang(0, 0, 0), ShowBones*ShowBonesAll, "models/sprops/geometry/sphere_3.mdl"),Bones["CamParent",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Root",number], noentity(), 0, vec(0, 0, 0), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Pelvis",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Pelvis",number], noentity(), 0, vec(0, 0, 8), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Spine1",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Spine1",number], noentity(), 0, vec(0, 0, 10), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Spine2",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Spine2",number], noentity(), 0, vec(1.5, 0, 16), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Head",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Spine2",number], noentity(), 0, vec(-1, 12, 9), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Shoulder",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Spine2",number], noentity(), 0, vec(-1, -12, 9), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Shoulder",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Spine2",number], noentity(), 0, vec(-1, 12, 9), ang(180, 0, -90), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_UpperArm",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Spine2",number], noentity(), 0, vec(-1, -12, 9), ang(180, 0, 90), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_UpperArm",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Left_UpperArm",number], noentity(), 0, vec(0, 0, Length1_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_ForeArm",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_UpperArm",number], noentity(), 0, vec(0, 0, Length1_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_ForeArm",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Left_ForeArm",number], noentity(), 0, vec(0, 0, Length2_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Hand",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_ForeArm",number], noentity(), 0, vec(0, 0, Length2_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Hand",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Left_ForeArm",number], noentity(), 0, vec(0, 0, Length2_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Hand_Real",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_ForeArm",number], noentity(), 0, vec(0, 0, Length2_Arm), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Hand_Real",number]=I
    
    
    I++, HN++, HT[HN,array] = array(I, Bones["Pelvis",number], noentity(), 0, vec(1, 6.5, -0.5), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_LegHelper",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Pelvis",number], noentity(), 0, vec(1, -6.5, -0.5), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_LegHelper",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Pelvis",number], noentity(), 0, vec(1, 6.5, -0.5), ang(0, 0, 180), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Thigh",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Pelvis",number], noentity(), 0, vec(1, -6.5, -0.5), ang(0, 0, 180), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Thigh",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Left_Thigh",number], noentity(), 0, vec(0, 0, Length1_Leg), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Calf",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_Thigh",number], noentity(), 0, vec(0, 0, Length1_Leg), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Calf",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Left_Calf",number], noentity(), 0, vec(0, 0, Length2_Leg), ang(0, 0, 180), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Foot",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_Calf",number], noentity(), 0, vec(0, 0, Length2_Leg), ang(0, 0, 180), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Foot",number]=I
    
    I++, HN++, HT[HN,array] = array(I, Bones["Root",number], noentity(), 0, vec(0, 0, (-Length1_Leg-Length2_Leg)), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Glider_Base",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Glider_Base",number], noentity(), 0, vec(0, 5, 0), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Glider_Arm",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Glider_Base",number], noentity(), 0, vec(0, -5, 0), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Glider_Arm",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Left_Glider_Arm",number], noentity(), 0, vec(0, 12, 12), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Left_Glider_Wing",number]=I
    I++, HN++, HT[HN,array] = array(I, Bones["Right_Glider_Arm",number], noentity(), 0, vec(0, -12, 12), ang(0, 0, 0), ShowBones, "models/sprops/geometry/sphere_3.mdl"),Bones["Right_Glider_Wing",number]=I
    
    if(Model){
        local Size = 1.5
        local Parent = Bones["Left_Foot",number]
        
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(2.8229, -0.0005, -0.9467)*Size, ang(95, 0, 0), vec(0.2275, 0.312, 0.4225)*Size, "models/sprops/misc/fittings/cred_12_9_tall.mdl", "", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.527, -0.0005, -1.447)*Size, ang(0, 90, 90), vec(0.4724, 0.3736, 2.679)*Size, "models/sprops/geometry/hhex_12.mdl", "", Color1, 0)
    	    CN++, CT[CN,table] = table(I, 1, vec(0, 0, 1.5)*Size, vec(0, 0, 1))
    
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, -0.8)*Size, ang(0, 0, 0), vec(0.36, 0.36, 0.21)*Size, "models/sprops/misc/fittings/cred_12_9_tall.mdl", "", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0)*Size, ang(0, 0, 0), vec(0.275, 1.32, 0.275)*Size, "models/sprops/geometry/fhex_12.mdl", "", Color1, 0)
    	
        
        local Parent = Bones["Right_Foot",number]
        
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(2.8229, -0.0005, -0.9467)*Size, ang(95, 0, 0), vec(0.2275, 0.312, 0.4225)*Size, "models/sprops/misc/fittings/cred_12_9_tall.mdl", "", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.527, -0.0005, -1.447)*Size, ang(0, 90, 90), vec(0.4724, 0.3736, 2.679)*Size, "models/sprops/geometry/hhex_12.mdl", "", Color1, 0)
    	    CN++, CT[CN,table] = table(I, 1, vec(0, 0, 1.5)*Size, vec(0, 0, 1))
    
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, -0.8)*Size, ang(0, 0, 0), vec(0.36, 0.36, 0.21)*Size, "models/sprops/misc/fittings/cred_12_9_tall.mdl", "", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0)*Size, ang(0, 0, 0), vec(0.275, 1.32, 0.275)*Size, "models/sprops/geometry/fhex_12.mdl", "", Color1, 0)
    	
        
        local Parent = Bones["Left_Calf",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.5542, 0, 8.8988), ang(8.6, 0, 0), vec(0.3, 0.2, 1.6), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0.2958, 0, 8.9977), ang(-1.3, 0, 0), vec(0.3, 0.15, 1.56), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 16.4), ang(0, 0, 0), vec(0.06, 0.06, 0.08), "models/hunter/tubes/tube1x1x1.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 9), ang(0, 0, 0), vec(0.3, 0.3, 1.6), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Right_Calf",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.5542, 0, 8.8988), ang(8.6, 0, 0), vec(0.3, 0.2, 1.6), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0.2958, 0, 8.9977), ang(-1.3, 0, 0), vec(0.3, 0.15, 1.56), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 16.4), ang(0, 0, 0), vec(0.06, 0.06, 0.08), "models/hunter/tubes/tube1x1x1.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 9), ang(0, 0, 0), vec(0.3, 0.3, 1.6), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Left_Thigh",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-0.8367, 0, 8.4548), ang(-1.6, 0, 0), vec(0.6, 0.3, 1.8), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        local Parent = Bones["Right_Thigh",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-0.8367, 0, 8.4548), ang(-1.6, 0, 0), vec(0.6, 0.3, 1.8), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
    
        local Parent = Bones["Pelvis",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 3.5), ang(0, 0, 0), vec(0.8, 0.7, 0.6), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0), ang(0, 0, 0), vec(0.9, 0.8, 0.4), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Spine1",number]
        
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-0.7916, 0, 3.4845), ang(-8.3, 0, 0), vec(0.8, 0.8, 1.1), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        
        local Parent = Bones["Spine2",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.8, -5.3, 5.4), ang(0, 0, 45), vec(0.7, 0.7, 1.1), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-6.9, 0, 4), ang(-66.244, 0, 0), vec(0.15, 0.13, 0.15), "models/hunter/triangles/trapezium3x3x1c.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.7, 0, 4.6), ang(0, 0, 0), vec(0.9, 1, 1.3), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-0.5, 0, 10.2), ang(0, 0, 0), vec(0.99, 1.265, 0.44), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.8, 5.3, 5.4), ang(0, 0, -45), vec(0.7, 0.7, 1.1), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(1.1494, 0, 14.7861), ang(15.8026, 0, 0), vec(0.1125, 0.1125, 0.1), "models/hunter/misc/squarecap2x2x2.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Head",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.5771, -3.874, 6.8687), ang(28.7, 10.6, 0), vec(0.98, 0.21, 0.56), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-1.5771, 3.874, 6.8687), ang(28.7, -10.6, 0), vec(0.98, 0.21, 0.56), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 3.3), ang(8, 0, 0), vec(0.77, 0.63, 0.7), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
    
        local Parent = Bones["Left_UpperArm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 10.1401), ang(0, 0, 0), vec(0.4, 0.25, 1.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, -2), ang(0, 0, 0), vec(0.6, 0.4, 0.9), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Right_UpperArm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 10.1401), ang(0, 0, 0), vec(0.4, 0.25, 1.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, -2), ang(0, 0, 0), vec(0.6, 0.4, 0.9), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Left_ForeArm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 7.14), ang(0, 0, 0), vec(0.3, 0.2, 1.5), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        local Parent = Bones["Right_ForeArm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 7.14), ang(0, 0, 0), vec(0.3, 0.2, 1.5), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", Color1, 0)
        
        
        Bones["Model_Start_ID",number] = I+1
        
        local Parent = Bones["Glider_Base",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0), ang(0, 0, 0), vec(0, 0, 0), "models/pac/default.mdl", "", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(11, 0, 0), ang(90, 0, 0), vec(0.5425, 0.62, 1.085), "models/holograms/hq_rcylinder.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-9.6, 0, 0), ang(90, 0, 0), vec(0.5425, 0.6975, 1.085), "models/holograms/hq_rcylinder.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(1, 0, 0), ang(90, 0, 0), vec(0.5425, 0.8525, 0.93), "models/holograms/hq_rcylinder.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(23.001, 0, -0.4), ang(0, 0, 180), vec(0.125, 0.2, 0.2), "models/props_combine/headcrabcannister01a.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-22.2881, 1.4863, -0.801), ang(85.855, -180, -180), vec(0.85, 0.85, 0.85), "models/sprops/cylinders/size_2/cylinder_3x18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(10.701, 0, -1.9), ang(0, 180, 180), vec(0.15, 0.175, 0.125), "models/props_combine/headcrabcannister01a.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-17.4, -0.31, 1.3), ang(-90, 0, 0), vec(0.575, 0.575, 0.575), "models/thrusters/jetpack.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-22.2881, -1.486, -0.801), ang(85.855, -180, -180), vec(0.85, 0.85, 0.85), "models/sprops/cylinders/size_2/cylinder_3x18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
    
        local Parent = Bones["Left_Glider_Arm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0), ang(0, 0, -45), vec(0.1, 0.1, 0.38), "models/props_c17/oildrum001.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
        
        
        local Parent = Bones["Right_Glider_Arm",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(0, 0, 0), ang(0, 0, 45), vec(0.1, 0.1, 0.38), "models/props_c17/oildrum001.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
        
        
        local Parent = Bones["Left_Glider_Wing",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(5.9419, -9.2761, -0.7544), ang(4.1946, 0, 4.3259), vec(3, 0.7, 0.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(22.4238, -9.8882, -2.1216), ang(0, 0, 4.2648), vec(1, 0.4, 0.7), "models/sprops/triangles/right/size_0_5/rtri_6x24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-9.6963, 40.1935, -5.5063), ang(11.2548, 7.925, 0), vec(1.3, 0.4, 0.5), "models/sprops/geometry/hhex_24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(5.9634, 0, -0.4604), ang(4.1946, 0, 0), vec(3, 1, 0.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(7.9414, 13.1282, -1.9917), ang(5.6905, 9.5545, -98.4972), vec(4.7, 0.9, 2.6), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-6.5972, 33.5074, -4.7705), ang(5.7173, 9.7356, -101.9064), vec(2, 0.8, 1.9), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(4.6116, 16.0381, -2.2266), ang(5.0704, 5.4805, -98.8793), vec(3.8, 0.8, 3.1), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(1.0471, 7.2664, 0.7124), ang(4.0456, 7.6455, 84.9875), vec(1.2, 0.3, 0.7), "models/sprops/geometry/fdisc_12.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(20.3638, -1.6219, -1.6216), ang(0, 0, 0), vec(1, 0.4, 0.7), "models/sprops/triangles/right/size_0_5/rtri_6x24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        
        local Parent = Bones["Right_Glider_Wing",number]
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(5.9419, 9.276, -0.7544), ang(4.1946, 0, -4.326), vec(3, 0.7, 0.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(7.9414, -13.128, -1.9917), ang(5.6905, -9.555, 98.497), vec(4.7, 0.9, 2.6), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(1.0471, -7.266, 0.7124), ang(4.0456, -7.646, -84.988), vec(1.2, 0.3, 0.7), "models/sprops/geometry/fdisc_12.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(22.4238, 9.888, -2.1216), ang(0, 0, -4.265), vec(1, 0.4, 0.7), "models/sprops/triangles/right/size_0_5/rtri_6x24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-6.5972, -33.507, -4.7705), ang(5.7173, -9.736, 101.906), vec(2, 0.8, 1.9), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(-9.6963, -40.194, -5.5063), ang(11.2548, -7.925, 0), vec(1.3, 0.4, 0.5), "models/sprops/geometry/hhex_24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(4.6116, -16.038, -2.2266), ang(5.0704, -5.481, 98.879), vec(3.8, 0.8, 3.1), "models/sprops/geometry/qhex_18.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(5.9634, 0, -0.4604), ang(4.1946, 0, 0), vec(3, 1, 0.2), "models/hunter/blocks/cube025x025x025.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
        I++, HN++, HT[HN,table] = table(I, Parent, noentity(), 0, vec(20.3638, 1.622, -1.6216), ang(0, 0, 0), vec(1, 0.4, 0.7), "models/sprops/triangles/right/size_0_5/rtri_6x24.mdl", "sprops/sprops_grid_12x12", vec4(255, 255, 255, 255), 0, 0)
    	
    }
    Bones["Model_End_ID",number] = I
    findIncludePlayerProps(owner())
    findInSphere(Base:pos(),1000)
    rangerFilter(findToArray())
    function vector bezier4( T, [P1 P2 P3 P4]:vector ) {
        return P1 * ( 1 - T ) ^ 3 + P2 * 3 * T * ( 1 - T ) ^ 2 + P3 * 3 * T ^ 2 * ( 1 - T ) + P4 * T ^ 3
    }
    function array:holo() {
        local Index = This[1, number]
        
        holoCreate(Index, (This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[5, vector]), (This[7, number] ? vec(This[7, number]) : This[7, vector]), (This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[6, angle]))
        holoParent(Index, This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity()))
        holoModel(Index, This:exists(8) ? This[8, string] : "cube")
        holoMaterial(Index, This:exists(9) ? This[9, string] : "")
        if(This:exists(10)){
            if(This[10, vector]!=vec()){
                holoColor(Index, This[10, vector])
            }elseif(This[10, vector4]!=vec4()){
                holoColor(Index, This[10, vector4])
            }else{
                holoColor(Index, vec(255))
            }
        }else{
            holoColor(Index, vec(255))
        }
        if(This[3,entity]:isValid() && This[3,entity] != noentity()){
            holoPos(Index,This[3,entity]:pos())
            holoAng(Index,This[3,entity]:angles())
            This[3,entity]:parentTo(holoEntity(Index))
            #This[3,entity]:setAlpha(255)
            holoPos(Index,(This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[5, vector]))
            holoAng(Index,(This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[6, angle]))
        }
        holoSkin(Index, This:exists(11) ? This[11, number] : 0)
    }
    
    function table:holo() {
        local Index = This[1, number]
        holoCreate(Index, (This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[5, vector]), (This[7, number] ? vec(This[7, number]) : This[7, vector]), (This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity())):toWorld(This[6, angle]))
        holoParent(Index, This[2,entity]:isValid() ? This[2,entity] : (holoEntity(This[2,number]):isValid() ? holoEntity(This[2,number]) : entity()))
        holoModel(Index, This:exists(8) ? This[8, string] : "cube")
        holoMaterial(Index, This:exists(9) ? This[9, string] : "")
        if(This:exists(10)){
            if(This[10, vector]!=vec()){
                #holoColor(Index, This[10, vector])
            }elseif(This[10, vector4]!=vec4()){
                #holoColor(Index, This[10, vector4])
            }else{
                #holoColor(Index, vec(255))
            }
            holoColor(Index, vec(100))
        }else{
            holoColor(Index, vec(255))
        }
        
        holoDisableShading(Index, This:exists(11) ? This[11, number] : 0)
    }

    #- Clip a hologram from data array
    function array:clip() {
        holoClipEnabled(This[1, number], This[2, number], 1)
        holoClip(This[1, number], This[2, number], This[3, vector], This[4, vector], 0)
    }
    function table:clip() {
        holoClipEnabled(This[1, number], This[2, number], 1)
        holoClip(This[1, number], This[2, number], This[3, vector], This[4, vector], 0)
    }
    #- Load the contraption
    function loadContraption() {
        switch (SpawnStatus) {
            case "InitSpawn",
                if (clk("Start")) {
                    SpawnStatus = "LoadHolograms"
                }
            break

            case "LoadHolograms",
                while (perf() & holoCanCreate() & (holoRemainingSpawns() > 5) &  SpawnCounter < HN) {
                    SpawnCounter++
                    HT[SpawnCounter, array]:holo()
                    HT[SpawnCounter, table]:holo()
                    if (SpawnCounter >= HN) {
                        SpawnStatus = CN > 0 ? "LoadClips" : "PrintStatus"
                        SpawnCounter = 0
                        break
                    }
                }
            break

            case "LoadClips",
                while (perf() & SpawnCounter < CN) {
                    SpawnCounter++
                    CT[SpawnCounter, array]:clip()
                    CT[SpawnCounter, table]:clip()

                    if (SpawnCounter >= CN) {
                        SpawnStatus = "PrintStatus"
                        SpawnCounter = 0
                        break
                    }
                }
            break

            case "PrintStatus",
                printColor( vec(222,37,188), "Holo Loader 3.0: ", vec(255,255,255), "Loaded " + HN + " holograms and " + CN + " clips." )

                HT:clear()
                CT:clear()

                CoreStatus = "InitPostSpawn"
                SpawnStatus = ""
            break
        }
    }
    
    function number icos(A, B, C) {
        return acos((A^2 + B^2 - C^2) / (2*A*B))    
    }
    function leg_ik(LeftRight,Rotation,Target:vector,StepLift){
        local Base=Bones[LeftRight ? "Right_LegHelper" : "Left_LegHelper",number]
        local NHip=Bones[LeftRight ? "Right_Thigh" : "Left_Thigh",number]
        local NKnee=Bones[LeftRight ? "Right_Calf" : "Left_Calf",number]
        local NFoot=Bones[LeftRight ? "Right_Foot" : "Left_Foot",number]
        
        holoAng(Base, holoEntity(Bones["Pelvis",number]):toWorld(ang(0,Rotation,0)))
        
        local Origin = holoEntity(NHip):pos()
        local AxisLocal = holoEntity(Base):toLocalAxis(Target - Origin)

        local AxisAngle = AxisLocal:toAngle():setRoll(-bearing(Target, holoEntity(Base):angles(), Origin)) #-- forward knee
        
        local LengthC = min(AxisLocal:length(), Length1_Leg + Length2_Leg)
        local AxisQuat = quat(AxisAngle) * qRotation(vec(0, 1, 0), 90 + icos(LengthC, Length1_Leg, Length2_Leg))
        
        holoAng(NHip, holoEntity(Base):toWorld(AxisQuat:toAngle()))
        holoAng(NKnee, holoEntity(NHip):toWorld(ang(icos(Length2_Leg, Length1_Leg, LengthC) + 180, 0, 0)))
        holoAng(NFoot, slerp(quat(holoEntity(Flying ? Bones[LeftRight ? "Right_Glider_Wing" : "Left_Glider_Wing",number] : Bones[LeftRight ? "Right_LegHelper" : "Left_LegHelper",number]):angles()),quat(holoEntity(NKnee):toWorld(ang(0,0,180))),Flying ? 0 : StepLift*MoveVal):toAngle())
    }
    function arm_ik(LeftRight,Rotation,Target:vector,AngleData:table){
        local Base=Bones[LeftRight ? "Right_Shoulder" : "Left_Shoulder",number]
        local NHip=Bones[LeftRight ? "Right_UpperArm" : "Left_UpperArm",number]
        local NKnee=Bones[LeftRight ? "Right_ForeArm" : "Left_ForeArm",number]
        local NFoot=Bones[LeftRight ? "Right_Hand" : "Left_Hand",number]
        local NFoot2=Bones[LeftRight ? "Right_Hand_Real" : "Left_Hand_Real",number]
        
        holoAng(Base, holoEntity(Bones["Spine2",number]):toWorld(ang(0,Rotation,0)))
        
        local Origin = holoEntity(NHip):pos()
        local AxisLocal = holoEntity(Base):toLocalAxis(Target - Origin)

        local AxisAngle = AxisLocal:toAngle():setRoll(-bearing(Origin, holoEntity(Base):angles(), Target)) #-- forward knee
        
        local LengthC = min(AxisLocal:length(), Length1_Arm + Length2_Arm)
        local AxisQuat = quat(AxisAngle) * qRotation(vec(0, 1, 0), 90 + icos(LengthC, Length1_Arm, Length2_Arm))
        
        holoAng(NHip, holoEntity(Base):toWorld(AxisQuat:toAngle()))
        holoAng(NKnee, holoEntity(NHip):toWorld(ang(icos(Length2_Arm, Length1_Arm, LengthC) + 180, 0, 0)))
        local Mix=AngleData[2,number]
        holoAng(NFoot, slerp(quat(holoEntity(Bones["Spine2",number]):toWorld(ang(160,0,0))),quat(AngleData[1,angle]),clamp(Mix,0,1)):toAngle())
        
        local HandAng = holoEntity(NFoot):angles()
        local HandAngLocal = holoEntity(NKnee):toLocal(holoEntity(NFoot):angles())
        
        holoAng(NFoot2, holoEntity(NKnee):toWorld(ang(0,HandAngLocal:yaw(),0)))
        
    }

    runOnTick(1)
    timer("Start", 500)
    CoreStatus = "InitSpawn"
    SpawnStatus = "InitSpawn"
    #ifdef entity:linkToPod(entity)
        PodController=spawnPodController(entity():pos()+vec(0,0,250),ang(),1,Seat)
        PodController:propDraw(0)
    #endif
}elseif (CoreStatus == "InitSpawn") {
    loadContraption()
}elseif (CoreStatus == "InitPostSpawn") {
    #- This is your "if (first())" section of the code.
    if(!EditMode){
        Base:propFreeze(0)
        #ifdef entity:linkToPod(entity)
            PodController:linkToPod(Seat)
            PodControllerW=PodController:wirelink()
            PodControllerW["Crosshairs",number]=1
        #endif
        Animation["current_weapon",string]="none"
        Landed=1
        timer("int",50)
        for(I=Bones["Model_Start_ID",number],Bones["Model_End_ID",number]){
            holoAlpha(I,0)
        }
    }else{
        leg_ik(0,5,holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(-2,7,3)),0)
        leg_ik(1,-5,holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(-2,-7,3)),0)
    }
    
    BoostData["unblockMovement",number]=1
    
    CamParent=holoEntity(Bones["CamParent",number])
    holoUnparent(Bones["Root",number])
    runOnTick(0)
    
    CoreStatus = "CodeRun"
}elseif(clk("int")){
    timer("int",50)
    
    Driver=Seat:driver()
    Ground_Ranger=rangerOffsetHull((Length1_Leg+Length2_Leg)+15+13*!Boosting,Base:pos(),vec(0,0,-1),vec(25/3.15,25/3.15,5))
    BASEANGVEL = slerp(quat(BASEANGVEL),quat(Base:angVel()),0.4):toAngle()
    On_Ground=(Ground_Ranger:distance()<=((Length1_Leg+Length2_Leg)+6+19*Flying))
    BaseVel=Base:vel()#Base:forward()*80#Base:vel()
    SP = Driver:keySprint()*On_Ground2*!Driver:keyPressed("s")
    M1 = Driver:keyAttack1()
    M2 = Driver:keyAttack2()
    W2 = Driver:keyPressed("w")*(On_Ground2|Flying)
    S2 = Driver:keyPressed("s")*(On_Ground2|Flying)
    A2 = Driver:keyPressed("a")*(On_Ground2|Flying)
    D2 = Driver:keyPressed("d")*(On_Ground2|Flying)
    UP = max(Driver:keyJump(),clamp(SpaceForABit*2,0,1))
    SL = 0#Driver:keyWalk()
    DN = Driver:keyWalk()
    
    LocalEyes = slerp(quat(LocalEyes),quat(Driver:isValid() ? SL ? LocalEyes : Driver:eyeAngles() : holoEntity(Bones["Head",number]):angles()),0.25):toAngle()
    
    if(changed(Driver:isPlayer())&Driver:isPlayer()){
        Base:propFreeze(0)
    }
    
    On_Ground2=(((holoEntity(Bones["Pelvis",number]):toWorld(vec(0,0,-42))-(holoEntity(Bones["Root",number]):pos())):z()>-4)*Ground_Ranger:hit()|On_Ground|Flying)*Landed
    if(On_Ground&DN&Flying){
        Landed=DN
        FlyingStart2=0
    }
    if(changed(UP)&UP&!Flying&!FlyingStart2){
        FlyingStart2=1
        Base:soundPlay("flightloop",0,"^thrusters/Rocket00.wav")
    }
    FlyingStartVal += 0.1*(FlyingStart2-!FlyingStart2)
    FlyingStartVal=clamp(FlyingStartVal,Flying*FlyingStart2,1)
    if(FlyingStart2&(FlyingStartVal>=1)&!Flying){
        Flying=1
        SpaceForABit=1
    }
    if(FlyingStartVal==0&Flying){
        Flying=0
        soundStop("flightloop")
    }
    soundPitch("flightloop",50*FlyingStart2+(100/(1+FlyingStart2))*FlyingStartVal+35*Base:vel():length()*0.002)
    
    SpaceForABit-=0.25
    SpaceForABit=clamp(SpaceForABit,0,1)
    W=W2
    S=S2
    A=A2
    D=D2
    
    MOVEW += 0.1*(W-!W)
    MOVEW=clamp(MOVEW,0,1)
    
    MOVES += 0.1*(S-!S)
    MOVES=clamp(MOVES,0,1)
    
    MOVEA += 0.1*(A-!A)
    MOVEA=clamp(MOVEA,0,1)
    
    MOVED += 0.1*(D-!D)
    MOVED=clamp(MOVED,0,1)
    
    Moving=W|S|A|D|UP|DN
    
    MoveVal += 0.15*(Moving-!Moving)
    MoveVal=clamp(MoveVal,0,1)
    
    DOWN += 0.15*(UP-!UP)
    DOWN=clamp(DOWN,0,1)
    
    ShiftVal += 0.1*(SP-!SP)
    ShiftVal=clamp(ShiftVal,0,MOVEW)
    
    if(Moving){
        if(SP){
            MOVEMAX += 0.2
        }
        elseif(SL){
            MOVEMAX += 0.05
        }
        else{
            MOVEMAX += 0.1
        }
    }else{
        MOVEMAX -= 0.1
    }
    MOVEMAX=clamp(MOVEMAX,0,1)
    if(Ground_Ranger:hit()|Flying){
        MOVEX = clamp(abs(MOVEW-MOVES)/sqrt(abs(MOVEW-MOVES)+abs(MOVED-MOVEA)),0,1)*sign(MOVEW-MOVES)*MOVEMAX
        MOVEY = clamp(abs(MOVED-MOVEA)/sqrt(abs(MOVEW-MOVES)+abs(MOVED-MOVEA)),0,1)*sign(MOVED-MOVEA)*MOVEMAX
    }
    else{
        MOVEX = 0
        MOVEY = 0
    }
    
    if(isnan(MOVEX)|isnan(MOVEY)){
        MOVEX = 0
        MOVEY = 0
    }
    
    Base:propGravity(!On_Ground*!Flying)
    
    if(changed(Driver)){
        Base:soundPlay("flightloop3",0,"^thrusters/Hover00.wav")
        Seat:propNotSolid(Driver:isValid())
        if(Driver==owner()){
            owner():setMaterial("null")
        }else{
            owner():setMaterial("")
        }
    }
    soundVolume("flightloop3",1*Flying*clamp(Base:vel():length()*0.01,0,1))
    if(!Seat:driver():isValid()){
        #ifdef entity:plySetPos(vector)
            foreach(I,E:entity=DriverTargets){
                if(changed(E:keyPressed("m"))&E:keyPressed("m")){
                    E:plyEnterVehicle(Seat)
                }
            }
        #else
            if(changed(owner():keyPressed("m"))&owner():keyPressed("m")){
                Seat:use()
            }
        #endif
    }
    Dir=vec(W-S,A-D,0):normalized()
    Dir2=LocalEyes:forward()
    if(Flying){
        Yaw=LocalEyes:yaw()
    }else{
        if(Dir:length()>0.1|(abs(holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw())>125)){
            Yaw+=((45*(MOVEA-MOVED)+PelvisAng:yaw()+holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw())/3)
        }
        Yaw=slerp(quat(ang(0,Yaw,0)),quat(BaseVel:toAngle(vec(0,0,1))),0.5*ShiftVal):toAngle():forward():toAngle(vec(0,0,1)):yaw()
        if(isnan(Yaw)){
            Yaw=holoEntity(Bones["Pelvis",number]):angles():yaw()
        }
    }
    
    Dir3=slerp(quat(ang(0,Dir2:toAngle(vec(0,0,1)):yaw(),0)),quat(ang(0,Yaw,0)),0.2):toAngle():forward():toAngle(vec(0,0,1))
    Dir4=Base:toLocal(Dir2:toAngle())
    if(!Flying){
        holoPos(Bones["Root",number],Ground_Ranger:position()+vec(0,0,49.5)-vec(0,0,BaseVel:z()*tickInterval()*15/2)*On_Ground)
    }
    
    
    HeightForce=vec(0,0,clamp((Length1_Leg+Length2_Leg) - Ground_Ranger:distance(),-(Length1_Leg+Length2_Leg)-6,(Length1_Leg+Length2_Leg)+6)*15)
    MoveForce=vec(MOVEX,-MOVEY,0):rotateAroundAxis(vec(0,0,1),LocalEyes:yaw())*(0.4+ShiftVal*0.4)*MOVEMAX*MoveVal*(1-sin(ShiftVal*180)*0.4*SP)*(M2*(1-ShiftVal) ? 0.6 : 1)
    DampForce=-(Base:toWorld(Base:velL())-Base:pos())
    if(Flying){
        Base:applyForce(((LocalEyes:forward()*MOVEX+LocalEyes:right()*MOVEY+vec(0,0,-DN*0.75*!On_Ground)+Base:up()*UP)*(500+(500*ShiftVal))*0.35+DampForce*0.1)*Base:mass())
        Base:applyAngForce((Base:toLocal(ang(LocalEyes:pitch()*ShiftVal,Yaw,0))*5-Base:angVel()*0.5)*Base:mass()*5)
    }else{
        Base:applyForce((Ground_Ranger:entity():vel()+HeightForce+MoveForce*BoostData["unblockMovement",number]*(300+(200*ShiftVal))+DampForce)*Base:mass()*On_Ground)
        Base:applyAngForce(-(Base:angles()*5+Base:angVel()*0.5)*Base:mass()*5)
    }
    
    Vel=((BaseVel/100)-(Ground_Ranger:entity():vel()/100))*0.3
    Add=(0.4+(Vel:setZ(0):length()*0.45))*(0.22-(0.05*ShiftVal))
    WalkRate+=Add
    WalkRate=clamp(WalkRate,0,!Flying)*On_Ground2
    Sin=sin(WalkRate*180)*MoveVal
    Sin2=sin((0.1+WalkRate)*180)*MoveVal
    Sin3=bezier(vec(),vec(1),vec(),WalkRate):x()*(Step-!Step)*MoveVal
    Sin4=sin(WalkRate*180)*MoveVal
    Cos=cos(WalkRate*90)*MoveVal
    Cos2=cos((0.5+WalkRate)*180)*MoveVal
    Distance=55+(20*ShiftVal)
    
    if(Flying){
        if(Moving&SP){
            Animation["state",string]="move_air"
        }else{
            Animation["state",string]="air_idle"
        }
    }else{
        if(Moving){
            if(SP){
                Animation["state",string]="run"
            }else{
                Animation["state",string]="walk"
            }
        }else{
            Animation["state",string]="idle"
        }
    }
    if(changed(Animation["state",string])){
        Animation["PelvisAngLast",angle]=Animation["PelvisAngNext",angle]
        Animation["PelvisOffsetLast",vector]=Animation["PelvisOffsetNext",vector]
        Animation["Spine1AngLast",angle]=Animation["Spine1AngNext",angle]
        Animation["Spine2AngLast",angle]=Animation["Spine2AngNext",angle]
        Animation["HeadAngLast",angle]=Animation["HeadAngNext",angle]
        Animation["MixAnim",number]=0
    }
    MoveL=Base:velL()*0.01
    switch(Animation["state",string]){
        case "idle",
            switch(Animation["current_weapon",string]){
                case "none",
                    Animation["PelvisAngNext",angle]=ang(0,0,0)
                    Animation["PelvisOffsetNext",vector]=vec(0,0,0)
                    Animation["Spine1AngNext",angle]=ang(0,0,0)
                    Animation["Spine2AngNext",angle]=ang(0,0,0)
                    Animation["HeadAngNext",angle]=ang(0,0,0)
                    
                    LeftArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(!Step-Step)*ShiftVal,19,-3+1*(1+ShiftVal*2)+2*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    RightArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(Step-!Step)*ShiftVal,-19,-3+1*(1+ShiftVal*2)+2*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    
                    RollArmLeft=25
                    RollArmRight=25
                break
            }
        break
        case "air_idle",
            switch(Animation["current_weapon",string]){
                case "none",
                    Animation["PelvisAngNext",angle]=ang(25*MOVEX-(MoveL:x()-MOVEX*(16+20*ShiftVal))*6,Yaw,25*MOVEY)*(1-ShiftVal)+ang(90+LocalEyes:pitch(),Yaw,0)*(ShiftVal)
                    Animation["PelvisOffsetNext",vector]=vec(15*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),10*BASEANGVEL:yaw()/90*ShiftVal,0)
                    Animation["Spine1AngNext",angle]=ang(-10*ShiftVal+25+10*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),15*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1),15*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1))
                    Animation["Spine2AngNext",angle]=ang(-15*ShiftVal+35+15*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),25*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1),25*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1))
                    Animation["HeadAngNext",angle]=ang(-15*MOVEX,0,-5*MOVEY)*(1-ShiftVal)+ang(-45,0,0)*(ShiftVal)
                    
                    LeftArmTarget1=holoEntity(Bones["Spine1",number]):toWorld(vec(6,35,0))
                    LeftArmTarget2=holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(25,5,-3))
                    LeftArmTarget=mix(LeftArmTarget1,LeftArmTarget2,clamp(-1+clamp(BASEANGVEL:yaw()/25*ShiftVal,0,5),1-ShiftVal,1))
                    RightArmTarget1=holoEntity(Bones["Spine1",number]):toWorld(vec(6,-35,0))
                    RightArmTarget2=holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(25,-5,-3))
                    RightArmTarget=mix(RightArmTarget1,RightArmTarget2,clamp(-1+clamp(-BASEANGVEL:yaw()/25*ShiftVal,0,5),1-ShiftVal,1))
                    
                    RollArmLeft=0
                    RollArmRight=0
                    
                    LeftLegFly=holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(0,-3,3))
                    RightLegFly=holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(0,3,3))
                break
            }
        break
        case "move_air",
            switch(Animation["current_weapon",string]){
                case "none",
                    Animation["PelvisAngNext",angle]=ang(25*MOVEX-(MoveL:x()-MOVEX*(16+20*ShiftVal))*6,Yaw,25*MOVEY)*(1-ShiftVal)+ang(90+LocalEyes:pitch(),Yaw,0)*(ShiftVal)
                    Animation["PelvisOffsetNext",vector]=vec(15*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),10*BASEANGVEL:yaw()/90*ShiftVal,0)
                    Animation["Spine1AngNext",angle]=ang(-10*ShiftVal+25+10*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),15*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1),15*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1))
                    Animation["Spine2AngNext",angle]=ang(-15*ShiftVal+35+15*sin((curtime()-0.5)*180*0.5)*(1-MoveVal),25*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1),25*clamp(BASEANGVEL:yaw()/90*ShiftVal,-1,1))
                    Animation["HeadAngNext",angle]=ang(-15*MOVEX,0,-5*MOVEY)*(1-ShiftVal)+ang(-45,0,0)*(ShiftVal)
                    
                    LeftArmTarget1=holoEntity(Bones["Spine1",number]):toWorld(vec(6,35,0))
                    LeftArmTarget2=holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(25,5,-3))
                    LeftArmTarget=mix(LeftArmTarget1,LeftArmTarget2,clamp(-1+clamp(BASEANGVEL:yaw()/25*ShiftVal,0,5),1-ShiftVal,1))
                    RightArmTarget1=holoEntity(Bones["Spine1",number]):toWorld(vec(6,-35,0))
                    RightArmTarget2=holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(25,-5,-3))
                    RightArmTarget=mix(RightArmTarget1,RightArmTarget2,clamp(-1+clamp(-BASEANGVEL:yaw()/25*ShiftVal,0,5),1-ShiftVal,1))
                    
                    RollArmLeft=0
                    RollArmRight=0
                    
                    LeftLegFly=holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(0,-3,3))
                    RightLegFly=holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(0,3,3))
                break
            }
        break
        case "walk",
            switch(Animation["current_weapon",string]){
                case "none",
                    Animation["PelvisAngNext",angle]=ang(0,0,0)
                    Animation["PelvisOffsetNext",vector]=vec(0,0,0)
                    Animation["Spine1AngNext",angle]=ang(5,0,5*Sin2*(Step-!Step)-6*(MOVEA-MOVED))
                    Animation["Spine2AngNext",angle]=ang(15,0,4*Sin*(Step-!Step)-12*(MOVEA-MOVED))
                    Animation["HeadAngNext",angle]=ang(5,0,0)
                    
                    LeftArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(!Step-Step)*ShiftVal,19,-3+1*(1+ShiftVal*2)+2*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    RightArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(Step-!Step)*ShiftVal,-19,-3+1*(1+ShiftVal*2)+2*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    
                    RollArmLeft=25
                    RollArmRight=25
                break
            }
        break
        case "run",
            switch(Animation["current_weapon",string]){
                case "none",
                    Animation["PelvisAngNext",angle]=ang(0,0,0)
                    Animation["PelvisOffsetNext",vector]=vec(0,0,0)
                    Animation["Spine1AngNext",angle]=ang(5,0,12*Sin2*(Step-!Step)-15*(MOVEA-MOVED))
                    Animation["Spine2AngNext",angle]=ang(35,0,8*Sin*(Step-!Step)-19*(MOVEA-MOVED))
                    Animation["HeadAngNext",angle]=ang(-5,0,0)
                    
                    LeftArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(!Step-Step)*ShiftVal,16,-3+1*(1+ShiftVal*2)+5*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    RightArmTarget=holoEntity(Bones["Pelvis",number]):toWorld(vec(4+10*ShiftVal+8*Sin4*(Step-!Step)*ShiftVal,-16,-3+1*(1+ShiftVal*2)+2*ShiftVal+2*Sin*(1+ShiftVal)):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):toLocal(LocalEyes):yaw()*0.5+35*Sin3))
                    
                    RollArmLeft=25
                    RollArmRight=25
                break
            }
        break
    }
    Animation["MixAnim",number]=Animation["MixAnim",number]+1/3
    Animation["MixAnim",number]=clamp(Animation["MixAnim",number],0,1)
    PelvisAng=slerp(quat(Animation["PelvisAngNext",angle]),quat(Animation["PelvisAngLast",angle]),1-Animation["MixAnim",number]):toAngle()
    PelvisOffset=mix(Animation["PelvisOffsetNext",vector],Animation["PelvisOffsetLast",vector],1-Animation["MixAnim",number])
    Spine1Ang=slerp(quat(Animation["Spine1AngNext",angle]),quat(Animation["Spine1AngLast",angle]),1-Animation["MixAnim",number]):toAngle()
    Spine2Ang=slerp(quat(Animation["Spine2AngNext",angle]),quat(Animation["Spine2AngLast",angle]),1-Animation["MixAnim",number]):toAngle()
    HeadAng=slerp(quat(Animation["HeadAngNext",angle]),quat(Animation["HeadAngLast",angle]),1-Animation["MixAnim",number]):toAngle()
    if(Animation["MixAnim",number]>=1){
        Animation["PelvisAngLast",angle]=Animation["PelvisAngNext",angle]
        Animation["PelvisOffsetLast",vector]=Animation["PelvisOffsetNext",vector]
        Animation["Spine1AngLast",angle]=Animation["Spine1AngNext",angle]
        Animation["Spine2AngLast",angle]=Animation["Spine2AngNext",angle]
        Animation["HeadAngLast",angle]=Animation["HeadAngNext",angle]
    }
    Vel2=Base:vel()*0.01
    
    if(Landed){
        Ranger2=rangerOffsetHull(100,holoEntity(Bones["Pelvis",number]):toWorld(vec(2,10-3*MoveVal,0))+mix(Vel:normalized()*clamp(Vel:length()*1.1,0,0.7)*Distance*On_Ground2,-Vel:normalized()*clamp(Vel:length()*1.1,0,0.7)*Distance*On_Ground2,WalkRate*Step+((1-WalkRate)*!Step)),vec(0,0,-1),vec(8,8,4))
        Ranger3=rangerOffsetHull(100,holoEntity(Bones["Pelvis",number]):toWorld(vec(-2,-10+3*MoveVal,0))+mix(Vel:normalized()*clamp(Vel:length()*1.1,0,0.7)*Distance*On_Ground2,-Vel:normalized()*clamp(Vel:length()*1.1,0,0.7)*Distance*On_Ground2,WalkRate*!Step+((1-WalkRate)*Step)),vec(0,0,-1),vec(8,8,4))
        LeftLeg=Ranger2:pos()
        RightLeg=Ranger3:pos()
    }else{
        LeftLeg=holoEntity(Bones["Pelvis",number]):toWorld(vec(0,9,0))+Vel2:setZ(0)-holoEntity(Bones["Pelvis",number]):up()*(Length1_Leg+Length2_Leg)*0.7
        RightLeg=holoEntity(Bones["Pelvis",number]):toWorld(vec(0,-9,0))+Vel2:setZ(0)-holoEntity(Bones["Pelvis",number]):up()*(Length1_Leg+Length2_Leg)*0.7
    }
    if(Ranger2:entity():owner()==owner()){
        rangerFilter(Ranger2:entity())
        rangerPersist(1)
    }
    if(Ranger3:entity():owner()==owner()){
        rangerFilter(Ranger3:entity())
        rangerPersist(1)
    }
    holoAng(Bones["Root",number],ang())
    holoAng(Bones["Glider_Base",number],holoEntity(Bones["Pelvis",number]):toWorld(ang(-105*ShiftVal+15*sin((curtime()+0.1)*180*0.5)/(1+MoveVal)*(1-ShiftVal),0,-15*clamp(BASEANGVEL:yaw(),-85,85)/90-5*sin((curtime()+0.1)*180*1.23*0.5)/(1+MoveVal)*(1-ShiftVal))))
    holoAng(Bones["Pelvis",number],holoEntity(Bones["Root",number]):toWorld(ang(PelvisAng:pitch()+12*sin(curtime()*180*0.5)/(1+MoveVal)*(1-ShiftVal),PelvisAng:yaw(),PelvisAng:roll()-12*sin(curtime()*180*1.23*0.5)/(1+MoveVal)*(1-ShiftVal)):rotateAroundAxis(Base:forward(),-clamp(BASEANGVEL:yaw(),-80,80)*0.4*ShiftVal+45*MOVEY*ShiftVal):rotateAroundAxis(Base:right(),90*DOWN/(1+MOVEW)*MOVEW*ShiftVal):rotateAroundAxis(Base:up(),-45*MOVEY*ShiftVal)*Flying+(ang(0,PelvisAng:yaw()+Yaw+5*Cos2*(Step-!Step),-(10/(5-(ShiftVal*4)))*On_Ground2*clamp(toLocalAng(vec(),LocalEyes,vec(),ang(0,holoEntity(Bones["Pelvis",number]):angles():yaw(),0)):yaw()*0.1,-1,1)*MoveVal+(5*MOVEY*(1+ShiftVal))-0.2*Sin*(Step-!Step))*!Flying*ang(On_Ground2,1,On_Ground2)):rotateAroundAxis(ang(0,LocalEyes:yaw(),0):forward(),-5*clamp(MOVEA-MOVED,-1,1)*(1+ShiftVal)*On_Ground2):rotateAroundAxis(ang(0,LocalEyes:yaw(),0):right(),-12*clamp(MOVEW-MOVES,-0.5,1)*(1+ShiftVal)*On_Ground2)*!Flying))
    if(Flying){
        local PosOnGround = holoEntity(Bones["Root",number]):toWorld(vec(PelvisOffset:x(),PelvisOffset:y(),Length1_Leg+Length2_Leg)+vec(0,0.2*Sin*(Step-!Step),-3*MoveVal):rotateAroundAxis(vec(0,0,1),Yaw))+Vel:normalized()*Vel:length()*12
        local PosOnGlider = holoEntity(Bones["Root",number]):toWorld(vec(PelvisOffset:x()-8*Flying*sin((curtime()+0.2)*180*0.5)/(1+MoveVal)*(1-ShiftVal),PelvisOffset:y()+8*Flying*sin((curtime()+0.2)*180*1.23*0.5)/(1+MoveVal)*(1-ShiftVal),Length1_Leg+Length2_Leg)*Landed)
        local Pos = bezier(PosOnGround,(PosOnGlider+PosOnGround)/2+vec(0,0,15),PosOnGlider,FlyingStartVal)
        holoPos(Bones["Pelvis",number],Pos)
        holoPos(Bones["Glider_Base",number],holoEntity(Bones["Pelvis",number]):toWorld(vec(3*ShiftVal-100*(1-FlyingStartVal),-10*BASEANGVEL:yaw()/90*ShiftVal-5*sin(curtime()*180*0.5),-(Length1_Leg+Length2_Leg)*0.8):rotateAroundAxis(vec(0,1,0),-100*ShiftVal)))
    }else{
        local PosOnGround = holoEntity(Bones["Root",number]):toWorld(vec(PelvisOffset:x(),PelvisOffset:y(),Length1_Leg+Length2_Leg)+vec(0,0.2*Sin*(Step-!Step),-3*MoveVal):rotateAroundAxis(vec(0,0,1),Yaw))+Vel:normalized()*Vel:length()*12
        local PosOnGlider = PosOnGround+vec(0,0,35)
        local Pos = bezier(PosOnGround,PosOnGlider+vec(0,0,25),PosOnGlider,FlyingStartVal)
        holoPos(Bones["Pelvis",number],Pos)
        
        holoPos(Bones["Glider_Base",number],holoEntity(Bones["Root",number]):toWorld(vec(-100*(1-FlyingStartVal),0,0):rotateAroundAxis(vec(0,0,1),holoEntity(Bones["Pelvis",number]):angles():yaw())+vec(0,0,30-15*FlyingStartVal)))
    }
    holoAng(Bones["Spine1",number],slerp(quat(Base:toWorld(ang(Spine1Ang:pitch()+25*DOWN+Dir4:pitch()*0.2*(1-ShiftVal)*!Flying,Dir4:yaw()+Spine1Ang:yaw(),Spine1Ang:roll())*ang(On_Ground2,1,On_Ground2))),quat(holoEntity(Bones["Pelvis",number]):angles()),0.6+0.2*ShiftVal):toAngle())
    holoAng(Bones["Spine2",number],slerp(quat(Base:toWorld(ang(Spine2Ang:pitch()+35*DOWN+Dir4:pitch()*0.4*(1-ShiftVal)*!Flying,Dir4:yaw()+Spine2Ang:yaw(),Spine2Ang:roll()):rotateAroundAxis(holoEntity(Bones["Spine1",number]):up(),(10+(55*ShiftVal))*Sin*(Step-!Step)*!Flying)*ang(On_Ground2,1,On_Ground2))),quat(holoEntity(Bones["Pelvis",number]):angles()),0.3+0.4*ShiftVal):toAngle())
    holoAng(Bones["Head",number],slerp(quat(Base:toWorld(ang(HeadAng:pitch()+LocalEyes:pitch()*0.5,Dir4:yaw()+HeadAng:yaw(),HeadAng:roll()))),quat(holoEntity(Bones["Pelvis",number]):angles()),0.4*ShiftVal):toAngle())
    if(WalkRate>=1){
        WalkRate=0
        Step=!Step
        if(MoveVal>0.1){
            if(ShiftVal>0.5){
                soundPlay("Step_"+Step,0,"physics/concrete/boulder_impact_hard3.wav")
            }else{
                soundPlay("Step_"+Step,0,"physics/body/body_medium_impact_soft3.wav")
            }
            soundPitch("Step_"+Step,50+30*clamp(Vel:length(),0,1))
        }
    }
    local RollGet = Base:toLocal(holoEntity(Bones["Glider_Base",number]):pos()):y()*0.75
    local Roll = clamp(RollGet/(1+abs(RollGet*0.025)),-12,12)
    holoAng(Bones["Left_Glider_Arm",number],holoEntity(Bones["Glider_Base",number]):toWorld(ang(0,0,clamp(-BASEANGVEL:yaw()/90,0,1)*35-abs(Roll)*Flying/(1+ShiftVal)*(1+(Roll<0))*(1+abs(Roll)/10))*0.5))
    holoAng(Bones["Right_Glider_Arm",number],holoEntity(Bones["Glider_Base",number]):toWorld(ang(0,0,-clamp(BASEANGVEL:yaw()/90,0,1)*35+abs(Roll)*Flying/(1+ShiftVal)*(1+(Roll>0))*(1+abs(Roll)/10))*0.5))
    holoAng(Bones["Left_Glider_Wing",number],holoEntity(Bones["Left_Glider_Arm",number]):toWorld(ang(15*clamp(-Base:velL():x()/53/15+MOVEX,-1,1)*Flying*(1-ShiftVal)+10*BASEANGVEL:yaw()/90*ShiftVal,0,-abs(Roll)*Flying/(1+ShiftVal)*(1+(Roll<0))*(1+abs(Roll)/10))))
    holoAng(Bones["Right_Glider_Wing",number],holoEntity(Bones["Right_Glider_Arm",number]):toWorld(ang(15*clamp(-Base:velL():x()/53/15+MOVEX,-1,1)*Flying*(1-ShiftVal)-10*BASEANGVEL:yaw()/90*ShiftVal,0,abs(Roll)*Flying/(1+ShiftVal)*(1+(Roll>0))*(1+abs(Roll)/10))))
    arm_ik(0,-RollArmLeft,LeftArmTarget,table(ang(),0))
    arm_ik(1,RollArmRight,RightArmTarget,table(ang(),0))
    if(!Flying){
        holoPos(Bones["Root",number],mix(LeftLeg,RightLeg,0.5))
    }else{
        holoPos(Bones["Root",number],Base:pos())
    }
    if(FlyingStartVal>0&FlyingStartVal<1){
        for(I=Bones["Model_Start_ID",number],Bones["Model_End_ID",number]){
            holoAlpha(I,255*clamp(-2+FlyingStartVal*4,0,1))
        }
    }
    if(Flying){
        local GliderPos = holoEntity(Bones["Left_Glider_Wing",number]):toWorld(vec(-2,7,3))
        local GroundPos = LeftLeg
        local LegPos = mix(GliderPos,GroundPos,clamp(FlyingStartVal*1.5,0,1))
        leg_ik(0,5,LegPos,0)
        
        local GliderPos = holoEntity(Bones["Right_Glider_Wing",number]):toWorld(vec(-2,-7,3))
        local GroundPos = RightLeg
        local LegPos = mix(GliderPos,GroundPos,clamp(FlyingStartVal*1.5,0,1))
        leg_ik(1,-5,LegPos,0)
    }else{
        leg_ik(0,5,LeftLeg+vec(0,0,(25+(5*ShiftVal))*sin(WalkRate*180)*Step)*clamp(Vel:length(),0,1)*!Flying,sin(WalkRate*180)*Step*!Flying)
        leg_ik(1,-5,RightLeg+vec(0,0,(25+(5*ShiftVal))*sin(WalkRate*180)*!Step)*clamp(Vel:length(),0,1)*!Flying,sin(WalkRate*180)*!Step*!Flying)
    }
    
    TP=PodControllerW["ThirdPerson",number]|!PodController:isValid()
    if(TP){
        holoPos(Bones["CamParent",number],holoEntity(Bones["Root",number]):toWorld(vec(-125,0+1.3*Sin*(Step-!Step)*(1+0.7*ShiftVal),55+1.5*(0.5-Sin)*(1+0.6*ShiftVal)):rotate(LocalEyes)))
    }else{
        holoPos(Bones["CamParent",number],holoEntity(Bones["Head",number]):toWorld(vec(15,0,0))-vec(0,0,32))
    }
    Seat:setAng(ang())
    Seat:setAlpha(75*!Seat:driver():isValid())
    
}
event removed(_){
    DriverStore:setMaterial("")
}
if(duped()){
    foreach(I:number,E:entity=BoneParents){
        E:deparent()
    }
}
if(clk("CanFire")){
    CanFire=1
}
if(changed(players():count())){
    rangerFilter(players())
    rangerPersist(1)
}
